#include "Pipeline.hpp"
#include "Resources.hpp"
#include <VulkanBackend/ErrorCheck.hpp>

void RecordCommands(int c, const VulkanBackend::BackendData& backendData, HawkEye::Pipeline::Private* pipelineData)
{
	VkCommandBuffer commandBuffer = pipelineData->frameData[c].commandBuffer;

	VkCommandBufferBeginInfo commandBufferBeginInfo{};
	commandBufferBeginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;

	VulkanCheck(vkBeginCommandBuffer(commandBuffer, &commandBufferBeginInfo));

	for (int b = 0; b < pipelineData->drawBufferCount; ++b)
	{
		if (pipelineData->drawBuffers[b].vertexBuffer->firstUse)
		{
			pipelineData->drawBuffers[b].vertexBuffer->firstUse = false;
			VulkanBackend::AcquireBufferOwnership(backendData, commandBuffer, pipelineData->drawBuffers[b].vertexBuffer->buffer.buffer,
				pipelineData->drawBuffers[b].vertexBuffer->dataSize, 0, VK_PIPELINE_STAGE_ALL_COMMANDS_BIT, VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT,
				VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT, pipelineData->drawBuffers[b].vertexBuffer->currentFamilyIndex, backendData.generalFamilyIndex);
			pipelineData->drawBuffers[b].vertexBuffer->currentFamilyIndex = backendData.generalFamilyIndex;
		}

		if (pipelineData->drawBuffers[b].indexBuffer && pipelineData->drawBuffers[b].indexBuffer->firstUse)
		{
			pipelineData->drawBuffers[b].indexBuffer->firstUse = false;
			VulkanBackend::AcquireBufferOwnership(backendData, commandBuffer, pipelineData->drawBuffers[b].indexBuffer->buffer.buffer,
				pipelineData->drawBuffers[b].indexBuffer->dataSize, 0, VK_PIPELINE_STAGE_ALL_COMMANDS_BIT, VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT,
				VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT, pipelineData->drawBuffers[b].indexBuffer->currentFamilyIndex, backendData.generalFamilyIndex);
			pipelineData->drawBuffers[b].indexBuffer->currentFamilyIndex = backendData.generalFamilyIndex;
		}
	}

	VkClearValue clearValues[1];
	clearValues[0].color = { 0.f, 0.f, 0.f };

	VkRenderPassBeginInfo renderPassBeginInfo{};
	renderPassBeginInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
	renderPassBeginInfo.renderPass = pipelineData->renderPass;
	renderPassBeginInfo.renderArea.extent.width = pipelineData->surfaceData->width;
	renderPassBeginInfo.renderArea.extent.height = pipelineData->surfaceData->height;
	renderPassBeginInfo.clearValueCount = 1;
	renderPassBeginInfo.pClearValues = clearValues;
	renderPassBeginInfo.framebuffer = pipelineData->framebuffers[c];
	vkCmdBeginRenderPass(commandBuffer, &renderPassBeginInfo, VK_SUBPASS_CONTENTS_INLINE);

	// HACK: Without dynamic viewports and other states, the pipeline might need to be recreated.
	VkViewport viewport;
	viewport.x = 0;
	viewport.y = 0;
	viewport.width = (float)pipelineData->surfaceData->width;
	viewport.height = (float)pipelineData->surfaceData->height;
	viewport.minDepth = 0.f;
	viewport.maxDepth = 1.f;
	vkCmdSetViewport(commandBuffer, 0, 1, &viewport);

	VkRect2D scissor;
	scissor.offset = { 0, 0 };
	scissor.extent = VkExtent2D{ (uint32_t)pipelineData->surfaceData->width, (uint32_t)pipelineData->surfaceData->height };
	vkCmdSetScissor(commandBuffer, 0, 1, &scissor);

	vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, pipelineData->rasterizationPipeline);

	// Display ray traced image generated by compute shader as a full screen quad
	// Quad vertices are generated in the vertex shader
	for (int b = 0; b < pipelineData->drawBufferCount; ++b)
	{
		//vkCmdBindDescriptorSets(p_->commandBuffers[c], VK_PIPELINE_BIND_POINT_GRAPHICS, p_->pipelineLayout,
		//	0, 1, &data.DescriptorSet, 0, NULL);
		static VkDeviceSize offset = 0;
		vkCmdBindVertexBuffers(commandBuffer, 0, 1, &pipelineData->drawBuffers[b].vertexBuffer->buffer.buffer, &offset);
		if (pipelineData->drawBuffers[b].indexBuffer)
		{
			vkCmdBindIndexBuffer(commandBuffer, pipelineData->drawBuffers[b].indexBuffer->buffer.buffer, offset, VK_INDEX_TYPE_UINT32);
			vkCmdDrawIndexed(commandBuffer, pipelineData->drawBuffers[b].indexBuffer->dataSize / 4, 1, 0, 0, 0);
		}
		else
		{
			vkCmdDraw(commandBuffer, pipelineData->drawBuffers[b].vertexBuffer->dataSize / pipelineData->vertexSize, 1, 0, 0);
		}
	}

	vkCmdEndRenderPass(commandBuffer);

	VulkanCheck(vkEndCommandBuffer(commandBuffer));

	pipelineData->frameData[c].dirty = false;
}

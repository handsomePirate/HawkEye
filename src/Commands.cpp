#include "Pipeline.hpp"
#include "Resources.hpp"
#include <VulkanBackend/ErrorCheck.hpp>

void PipelineUtils::RecordCommands(int c, const VulkanBackend::BackendData& backendData, HawkEye::Pipeline::Private* pipelineData)
{
	VkCommandBuffer commandBuffer = pipelineData->frameData[c].commandBuffer;

	VkCommandBufferBeginInfo commandBufferBeginInfo{};
	commandBufferBeginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;

	VulkanCheck(vkBeginCommandBuffer(commandBuffer, &commandBufferBeginInfo));

	VkClearValue clearValues[1];
	clearValues[0].color = { 0.f, 0.f, 0.f };

	VkRenderPassBeginInfo renderPassBeginInfo{};
	renderPassBeginInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
	renderPassBeginInfo.renderPass = pipelineData->renderPass;
	renderPassBeginInfo.renderArea.extent.width = pipelineData->surfaceData->width;
	renderPassBeginInfo.renderArea.extent.height = pipelineData->surfaceData->height;
	renderPassBeginInfo.clearValueCount = 1;
	renderPassBeginInfo.pClearValues = clearValues;
	renderPassBeginInfo.framebuffer = pipelineData->framebuffers[c];
	vkCmdBeginRenderPass(commandBuffer, &renderPassBeginInfo, VK_SUBPASS_CONTENTS_INLINE);

	// HACK: Without dynamic viewports and other states, the pipeline might need to be recreated.
	VkViewport viewport;
	viewport.x = 0;
	viewport.y = 0;
	viewport.width = (float)pipelineData->surfaceData->width;
	viewport.height = (float)pipelineData->surfaceData->height;
	viewport.minDepth = 0.f;
	viewport.maxDepth = 1.f;
	vkCmdSetViewport(commandBuffer, 0, 1, &viewport);

	VkRect2D scissor;
	scissor.offset = { 0, 0 };
	scissor.extent = VkExtent2D{ (uint32_t)pipelineData->surfaceData->width, (uint32_t)pipelineData->surfaceData->height };
	vkCmdSetScissor(commandBuffer, 0, 1, &scissor);

	for (int p = 0; p < pipelineData->passData.size(); ++p)
	{
		// TODO: Different binding for different pipeline.
		vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, pipelineData->passData[p].rasterizationPipeline);

		for (int m = 0; m < pipelineData->passData[p].materials.size(); ++m)
		{
			auto it = pipelineData->passData[p].drawBuffers.find(m);
			if (it == pipelineData->passData[p].drawBuffers.end())
			{
				continue;
			}

			std::vector<VkDescriptorSet> descriptorSets;
			descriptorSets.reserve(2);
			if (pipelineData->passData[p].materials[m].descriptorSet != VK_NULL_HANDLE)
			{
				descriptorSets.push_back(pipelineData->passData[p].materials[m].descriptorSet);
			}
			if (pipelineData->passData[p].descriptorData.descriptorSet != VK_NULL_HANDLE)
			{
				descriptorSets.push_back(pipelineData->passData[p].descriptorData.descriptorSet);
			}
			if (pipelineData->descriptorData.descriptorSet != VK_NULL_HANDLE)
			{
				descriptorSets.push_back(pipelineData->descriptorData.descriptorSet);
			}
			if (descriptorSets.size() > 0)
			{
				vkCmdBindDescriptorSets(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, pipelineData->passData[p].pipelineLayout, 0,
					descriptorSets.size(), descriptorSets.data(), 0, nullptr);
			}

			// Display ray traced image generated by compute shader as a full screen quad
			// Quad vertices are generated in the vertex shader
			for (int b = 0; b < it->second.size(); ++b)
			{
				static VkDeviceSize offset = 0;
				vkCmdBindVertexBuffers(commandBuffer, 0, 1, &it->second[b].vertexBuffer->buffer.buffer, &offset);
				vkCmdBindVertexBuffers(commandBuffer, 1, 1, &it->second[b].instanceBuffer->buffer.buffer, &offset);
				if (it->second[b].indexBuffer)
				{
					vkCmdBindIndexBuffer(commandBuffer, it->second[b].indexBuffer->buffer.buffer, offset, VK_INDEX_TYPE_UINT32);
					vkCmdDrawIndexed(commandBuffer, it->second[b].indexBuffer->dataSize / 4, it->second[b].instanceBuffer->dataSize / 64, 0, 0, 0);
				}
				else
				{
					vkCmdDraw(commandBuffer, it->second[b].vertexBuffer->dataSize / pipelineData->passData[p].vertexSize, it->second[b].instanceBuffer->dataSize / 64, 0, 0);
				}
			}
		}
	}

	vkCmdEndRenderPass(commandBuffer);

	VulkanCheck(vkEndCommandBuffer(commandBuffer));

	pipelineData->frameData[c].dirty = false;
}

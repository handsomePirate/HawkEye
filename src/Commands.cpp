#include "Pipeline.hpp"
#include "Resources.hpp"
#include <VulkanBackend/ErrorCheck.hpp>

void RecordCommands(int c, const VulkanBackend::BackendData& backendData, HawkEye::Pipeline::Private* pipelineData)
{
	VkCommandBuffer commandBuffer = pipelineData->frameData[c].commandBuffer;

	VkCommandBufferBeginInfo commandBufferBeginInfo{};
	commandBufferBeginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;

	VulkanCheck(vkBeginCommandBuffer(commandBuffer, &commandBufferBeginInfo));

	VkClearValue clearValues[1];
	clearValues[0].color = { 0.f, 0.f, 0.f };

	VkRenderPassBeginInfo renderPassBeginInfo{};
	renderPassBeginInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
	renderPassBeginInfo.renderPass = pipelineData->renderPass;
	renderPassBeginInfo.renderArea.extent.width = pipelineData->surfaceData->width;
	renderPassBeginInfo.renderArea.extent.height = pipelineData->surfaceData->height;
	renderPassBeginInfo.clearValueCount = 1;
	renderPassBeginInfo.pClearValues = clearValues;
	renderPassBeginInfo.framebuffer = pipelineData->framebuffers[c];
	vkCmdBeginRenderPass(commandBuffer, &renderPassBeginInfo, VK_SUBPASS_CONTENTS_INLINE);

	// HACK: Without dynamic viewports and other states, the pipeline might need to be recreated.
	VkViewport viewport;
	viewport.x = 0;
	viewport.y = 0;
	viewport.width = (float)pipelineData->surfaceData->width;
	viewport.height = (float)pipelineData->surfaceData->height;
	viewport.minDepth = 0.f;
	viewport.maxDepth = 1.f;
	vkCmdSetViewport(commandBuffer, 0, 1, &viewport);

	VkRect2D scissor;
	scissor.offset = { 0, 0 };
	scissor.extent = VkExtent2D{ (uint32_t)pipelineData->surfaceData->width, (uint32_t)pipelineData->surfaceData->height };
	vkCmdSetScissor(commandBuffer, 0, 1, &scissor);

	// TODO: Move common commands outside of the loop.

	// TODO: Different binding for different pipeline.
	vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, pipelineData->rasterizationPipeline);

	for (int m = 0; m < pipelineData->materials.size(); ++m)
	{
		auto it = pipelineData->drawBuffers.find(m);
		if (it == pipelineData->drawBuffers.end())
		{
			continue;
		}

		std::vector<VkDescriptorSet> descriptorSets;
		descriptorSets.reserve(2);
		if (pipelineData->materials[m].descriptorSet != VK_NULL_HANDLE)
		{
			descriptorSets.push_back(pipelineData->materials[m].descriptorSet);
		}
		if (pipelineData->frameData[0].descriptorSet != VK_NULL_HANDLE)
		{
			descriptorSets.push_back(pipelineData->frameData[0].descriptorSet);
		}
		if (descriptorSets.size() > 0)
		{
			vkCmdBindDescriptorSets(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, pipelineData->pipelineLayout, 0,
				descriptorSets.size(), descriptorSets.data(), 0, nullptr);
		}

		// Display ray traced image generated by compute shader as a full screen quad
		// Quad vertices are generated in the vertex shader
		for (int b = 0; b < it->second.size(); ++b)
		{
			static VkDeviceSize offset = 0;
			vkCmdBindVertexBuffers(commandBuffer, 0, 1, &it->second[b].vertexBuffer->buffer.buffer, &offset);
			if (it->second[b].indexBuffer)
			{
				vkCmdBindIndexBuffer(commandBuffer, it->second[b].indexBuffer->buffer.buffer, offset, VK_INDEX_TYPE_UINT32);
				vkCmdDrawIndexed(commandBuffer, it->second[b].indexBuffer->dataSize / 4, 1, 0, 0, 0);
			}
			else
			{
				vkCmdDraw(commandBuffer, it->second[b].vertexBuffer->dataSize / pipelineData->vertexSize, 1, 0, 0);
			}
		}
	}

	vkCmdEndRenderPass(commandBuffer);

	VulkanCheck(vkEndCommandBuffer(commandBuffer));

	pipelineData->frameData[c].dirty = false;
}
